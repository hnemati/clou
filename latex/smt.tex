\documentclass{article}

\usepackage{amsmath}

% Custom commands
\newcommand{\kind}{\texttt{kind}}
\newcommand{\ENTRY}{\texttt{ENTRY}}
\newcommand{\EXIT}{\texttt{EXIT}}
\newcommand{\READ}{\texttt{READ}}
\newcommand{\WRITE}{\texttt{WRITE}}

\newcommand{\po}{\texttt{po}}
\newcommand{\tfo}{\texttt{tfo}}
\newcommand{\com}{\texttt{com}}
\newcommand{\comx}{\texttt{comx}}

\newcommand{\preds}{\texttt{preds}}
\newcommand{\succs}{\texttt{succs}}
\newcommand{\nodes}{\texttt{nodes}}

\newcommand{\arch}{\texttt{arch}}
\newcommand{\trans}{\texttt{trans}}
\newcommand{\exec}{\texttt{exec}}
\newcommand{\transdepth}{\texttt{trans\_depth}}
\newcommand{\addr}{\texttt{addr}}
\newcommand{\xsread}{\texttt{xsread}}
\newcommand{\xswrite}{\texttt{xswrite}}

\newcommand{\numspecs}{\texttt{num\_specs}}

\newcommand{\rf}{\texttt{rf}}
\newcommand{\co}{\texttt{co}}
\newcommand{\fr}{\texttt{fr}}

\newcommand{\rfx}{\texttt{rfx}}
\newcommand{\cox}{\texttt{cox}}
\newcommand{\frx}{\texttt{frx}}

\newcommand{\closure}[1]{#1^\wedge}

\newcommand{\writes}{\texttt{writes}}
\newcommand{\reads}{\texttt{reads}}

\newcommand{\xwrites}{\texttt{xwrites}}
\newcommand{\xreads}{\texttt{xreads}}
\newcommand{\xstate}{\texttt{xstate}}

\title{LCM SMT Formulas}
\author{Nicholas Mosier}

\begin{document}
\maketitle

\section{Nodes}

\subsection{Variables}

% TODO: Redefine \transdepth to use incoming tfo edges?

Each node has its own copy of the following variables.

\begin{centering}
\begin{tabular}{|c|c|c|l|}\hline
  {\bf Name} & {\bf Type} & {\bf Symbolic?} & {\bf Description} \\\hline
\kind & enum Kind & no & the type of this node \\\hline  
\arch & bool & yes & whether this instruction architecturally executes (commits) \\\hline
\trans & bool & yes & whether this instruction transiently executes but does not commit \\\hline
\transdepth & int & yes & transient fetch order depth of this instruction (if \trans) \\\hline
\addr & int & yes & symbolic address accessed by memory access instruction \\\hline
\xsread, \xswrite{} & bool & yes & whether this instruction reads or writes xstate, respectively \\\hline
\end{tabular}
\end{centering}
% \begin{itemize}
% \item \arch (bool) -- whether this instruction architecturally executes (commits)
% \item \trans (bool) -- whether this instruction transiently executes but does not commit
% \item \transdepth{} (int) -- transient fetch order depth of this instruction (if \trans)
% \item \addr{} (int) -- symbolic address accessed by memory access instruction
% \item \xsread, \xswrite{} (bool) -- whether this instruction reads or writes xstate, respectively
% \end{itemize}

\begin{verbatim}
enum Kind {ENTRY, EXIT, READ, WRITE, FENCE, OTHER};
\end{verbatim}

\subsection{Constraints}
\begin{itemize}
\item Exclusive architectural/transient execution: $\neg \left( v.\arch \wedge v.\trans \right)$.
\item Program entry node is architecturally executed: $\top.\arch$.
\item Limit transient execution depth: $v.\tfo \implies v.\transdepth < \numspecs$.
\item Calculating transient depth \transdepth:
  \begin{itemize}
  \item Architectural execution resets transient depth:
    $v.\arch \implies v.\transdepth = 0$.
  \item Transient fetch increments transient depth:
    $\tfo(u,v) \implies v.\transdepth = u.\transdepth + 1$.
  \end{itemize}
\item xstate accesses:
  \begin{itemize}
  \item \READ{}s are always xstate reads and sometimes xstate writes:
    $\forall v \in \nodes, v.\kind = \READ \implies v.\xsread$.
  \item \WRITE{}s are always xstate read-writes:
    $\forall v \in \nodes, v.\kind = \WRITE \implies v.\xsread \wedge v.\xswrite$.
  \end{itemize}
\end{itemize}

\section{Definitions}
\begin{tabular}{|c|c|l|}\hline
  {\bf Name} & {\bf Average Size} & {\bf Definition} \\\hline
  \nodes    & $N$ & the set of all nodes in the AEG \\\hline
  $\top$    & $1$ & the unique node $\top \in \nodes \mid v.\ENTRY$ \\\hline
  $\bot$    & $1$ & the unique node $\bot \in \nodes \mid v.\EXIT$ \\\hline
  \reads    & $O(N)$ & $\{v \in \nodes \mid v.\kind \in \{\READ, \EXIT\}$, i.e., the set of all reads plus the exit node \\\hline
  \writes   & $O(N)$ & $\{v \in \nodes \mid v.\kind \in \{\WRITE, \ENTRY\}$, i.e., the set of all writes plus the entry node \\\hline
%   \xsreads  & & the set of all xstate reads \\\hline
%   \xswrites & & the set of all xstate writes \\\hline
  \preds    & $O(1)$ per entry & a map $\nodes \to 2^\nodes$ mapping nodes to their predecessors in the final CFG \\\hline
  \succs  & $O(1)$ per entry  & a map $\nodes \to 2^\nodes$ mapping nodes to their successors in the final CFG \\\hline
\end{tabular}

\section{\po}

Domain: $\po(u,v)$ is defined for all $u,v \in \nodes$ such that $v \in \succs[u]$.
\\
Constraints:
\begin{itemize}
\item Exactly one predecessor:
  $\forall v \in \nodes \setminus \{\top\}, v.\arch \implies \exists!\, u \in \preds[v] \mid
  \po(u,v).$
\item Exactly one successor: $\forall v \in \nodes \setminus \{\bot\}, v.\arch \implies
  \exists!\, u \in \succs[v] \mid \po(u,v).$
\item Execution conditions: $\po(u,v) \implies u.\arch \wedge v.\arch.$
\end{itemize}
Complexity:
\begin{itemize}
\item Edge count: $O(N)$
\item Constraints: $O(N)$
\end{itemize}

\section{\tfo}

Domain: $\tfo(u,v)$ is defined for all $u,v \in \nodes$ such that $v \in \succs[u]$ and $\preds[v] = \{u\}$.
(Note that this last requirement is sound due to the loop-free CFG expansion step.)
\\
Constraints:
\begin{itemize}
\item Execution conditions: $\tfo(u,v) \implies \left( u.\arch \vee u.\trans \right) \wedge v.\trans.$
\item At most one successor:
  $\forall u \in \nodes, \forall \mbox{ distinct } v,w \in \nodes, \neg \left( \tfo(u,v) \wedge \tfo(u, w) \right).$
\item Transient execution requires incoming tfo edge:
  $\forall u \in \nodes, u.\trans \implies \exists v \in \nodes \mid
  \tfo(u,v).$
\end{itemize}
Complexity:
\begin{itemize}
\item Edge count: $O(N)$
\item Constraints: $O(N)$
\end{itemize}


\section{\rf}
Domain: $\rf(u,v)$ is defined for all $u,v \in \nodes$ such that $u \in \writes \wedge v \in \reads \wedge u \in \closure{\preds}[v]$.
\\
Constraints:
\begin{itemize}
\item Same address: $\rf(u,v) \implies u.\addr = v.\addr$.
\item Execution condition: $\rf(u,v) \implies u.\arch \wedge v.\arch$.
\item Most recent write: $\rf(u,v) \implies
  \forall w \in \left( \writes \cap \closure{\preds}[v] \right), \neg \co(u,w)$.
\item Required: $\forall v \in \reads, v.\arch \implies \exists u \in \writes \mid \rf(u,v)$.
\end{itemize}
Complexity:
\begin{itemize}
\item Edge count: $O(N^2)$ (improvement possible if we're smart about which writes we consider)
\item Constraints: $O(N^2)$
\end{itemize}

\section{\co}
Domain: $\co(u,v)$ is defined for all $u,v \in \nodes$ such that $u \in \writes \wedge v \in \writes \wedge u \neq v \wedge v \in \closure{\succs}[u]$.
\\
Constraints:
\begin{itemize}
\item Definition: $\co(u,v) \iff u.\arch \wedge v.\arch \wedge u.\addr = v.\addr$.
\end{itemize}
Complexity:
\begin{itemize}
\item Edge count: $O(N^2)$ (improvement impossible unless we make edges implicit)
\item Constraints: $O(N^2)$
\end{itemize}


\section{\fr}
Domain: $\fr(u,v)$ is defined for all $u,v \in \nodes$ such that $u \in \reads \wedge v \in \writes^\bot \wedge v \in \closure{\succs}[u]$.
\\
Constraints:
\begin{itemize}
\item Definition: $\fr(u,v) \iff u.\arch \wedge v.\arch \wedge u.\addr = v.\addr$.
\end{itemize}
Complexity:
\begin{itemize}
\item Edge count: $O(N^2)$ (modeling \fr may not be necessary)
\item Constraints: $O(N^2)$
\end{itemize}


\section{\rfx}
Domain: $\rfx(u,v)$ is defined for all $u,v \in \nodes$ such that $u \in \xwrites \wedge v \in \xreads \wedge u \neq v$.
\\
Constraints:
\begin{itemize}
\item Same xstate: $\rfx(u,v) \implies u.\xstate = v.\xstate$.
\item Execution condition: $\rfx(u,v) \implies u.\exec \wedge v.\exec$.
\item Required: $\forall v \in \xreads, v.\exec \implies \exists!\,u \in \xwrites \mid
  \rfx(u,v)$.
\end{itemize}
Complexity:
\begin{itemize}
\item Edge count: $O(N^2)$ (dependent on our microarchitectural model)
\item Constraints: $O(N^2)$
\end{itemize}


\section{\cox}
Domain: $\cox(u,v)$ is defined $u,v \in \nodes$ such that
$u,v \in \xwrites \wedge u \neq v$.
\\
Constraints:
\begin{itemize}
\item Same xstate: $\cox(u,v) \implies u.\xstate = v.\xstate$.
\item Execution condition: $\cox(u,v) \implies u.\exec \wedge v.\exec$.
\item Total order: $\forall u \in \xwrites, v \in \xwrites, u.\exec \wedge v.\exec \wedge u \neq v \implies \cox(u,v) \vee \cox(v,u)$.
\item Acyclic: $\text{acyclic}[\cox]$. (Unknown complexity)
\end{itemize}
Complexity:
\begin{itemize}
\item Edge count: $O(N^2)$
\item Constraints: $O(N^2)$?
\end{itemize}

\section{\frx}
Domain: $\frx(u,v)$ is defined for all $u,v \in \nodes$ such that $u \in \xreads \wedge v \in \xwrites \wedge u \neq v$.
\\
Constraints:
\begin{itemize}
\item Definition: $\frx(u,v) \iff \exists w \in \xwrites \mid
  \rfx(w,u) \wedge \cox(w,v)$.
\end{itemize}
Complexity:
\begin{itemize}
\item Edge count: $O(N^2)$
\item Constraints: $O(N^3)$ (\frx{} may not be necessary) 
\end{itemize}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
